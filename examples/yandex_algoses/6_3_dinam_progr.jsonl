{"document_title": "Динамическое программирование - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/dinamicheskoe-programmirovanie", "section_title": "Ключевые вопросы параграфа", "text": "Как работает динамическое программирование и зачем оно нужно? Как разбивать задачу на подзадачи и переиспользовать решения? Когда стоит выбрать универсальный алгоритм, а когда — частный и быстрый?", "useful_links": []}
{"document_title": "Динамическое программирование - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/dinamicheskoe-programmirovanie", "section_title": "Что такое динамическое программирование", "text": "Некоторые алгоритмы разбивают задачу на более мелкие подзадачи и используют решения подзадач, чтобы собрать решение для главной. Во время этого процесса количество подзадач может стать очень большим, и некоторые алгоритмы решают одну и ту же подзадачу многократно, что чрезмерно увеличивает время выполнения. Динамическое программирование упорядочивает вычисления и позволяет не вычислять уже известные значения повторно. Зачастую это экономит массу времени. Задача со звонящим телефоном не подразумевает решения с помощью динамического программирования, поэтому мы рассмотрим другую. Представьте, что вместо ответа на звонок вы решаете поиграть в «Камни»: игру для двух игроков с двумя наборами камней по десять штук. С каждым ходом один игрок может взять один камень (из любого набора) или два камня (по одному из обоих). Когда камень забрали, он выходит из игры. Побеждает игрок, который заберет последний камень. Первый ход за вами. Чтобы найти стратегию для выигрыша в игре на, мы можем составить таблицу, которую мы назовем(рис.). Вместо того, чтобы решать задачу скамнями в каждом из наборов, мы решим более общую задачу скамней в одном наборе икамней в другом (игра на), гдеи— это произвольные целые неотрицательные числа. Если игрок 1 может гарантированно выигрывать игру на, тогда мы будем говорить, что. Если у игрока 1 нет стратегии для выигрыша против игрока, который всегда делает правильные ходы, мы будем писать. Вычислениедля произвольныхиможет звучать сложно, но мы воспользуемся результатами вычислений для меньших значений. Некоторые варианты игры, — в особенности,и, — явно приведут к победе игрока 1, так как игрок 1 может выиграть первым ходом. Таким образом, мы заполняем ячейки,икак.рис. (a) Заполнив ячейки,и, можно попробовать заполнить другие. Например, в случае сединственный ход, который может сделать игрок 1, приводит к— это выигрышный вариант для оппонента. Аналогичный анализ применим к случаю, что приводит к таблице из рис.рис. (b). В случаеигрок 1 может сделать три разных хода, которые приведут к,исоответственно. Один из этих случаев,, приводит к проигрышной позиции оппонента. Соответственно,— это выигрышная позиция. Случаиисимметричны, поэтому мы получаем таблицу из рис.рис. (c). Теперь мы можем заполнить. В случаеигрок 1 может сделать три разных хода, которые приведут к ячейкам,и. Эти ячейки — выигрышные позиции для оппонента. Так,: см рис.рис. (d). Мы можем продолжить заполнять, обращая внимание на то, что ячейкабудет, если ячейки сверху, слева и слева по диагонали будут. Эти ячейки (,и) соответствуют трем ходам, которые может сделать игрок 1. См. рис.рис. (e) АлгоритмRocksопределяет, выиграет игрок 1 или нет. Если игрок 1 выигрывает, тоRocksвыдаст. Если игрок 1 проигрывает, тоRocksвыдаст. Мы ввели искусственное начальное условие,, чтобы упростить псевдокод. Скопировать код1Rocks(n, m):2R(0,0) = L3fori from1to n:4ifR(i-1,0) = W:5R(i,0) = L6else:7R(i,0) = W8forj from1to m:9ifR(0,j-1) = W:10R(0,j) = L11else:12R(0,j) = W13fori from1to n:14forj from1to m:15ifR(i-1,j-1)=WandR(i,j-1)=WandR(i-1,j)=W:16R(i,j) = L17else:18R(i,j) = W19returnR(n,m) Более быстрый алгоритм для решения этой головоломки опирается на простую закономерность ви проверяет, чётныеиили нет. Если оба числа чётные, то игрок проигрывает (см. таблицу выше). Скопировать код1FastRocks(n, m):2ifn %2==0andm %2==0:// оба числа чётные3returnL4else:5returnW Тем не менее, хотяFastRocksи эффективнее, чемRocks, изменить его для схожих вариантов игры может быть сложно. Например, вариант, в котором игрок может убирать до трёх камней из наборов. Перед нами пример того, как более медленный алгоритм может быть полезнее, чем быстрый.", "useful_links": [{"text": "рис.", "url": "#Placeholder-1-6"}, {"text": "рис. (a)", "url": "#Placeholder-1-6"}, {"text": "рис. (b)", "url": "#Placeholder-1-6"}, {"text": "рис. (c)", "url": "#Placeholder-1-6"}, {"text": "рис. (d)", "url": "#Placeholder-1-6"}, {"text": "рис. (e)", "url": "#Placeholder-1-6"}]}
{"document_title": "Динамическое программирование - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/dinamicheskoe-programmirovanie", "section_title": "Что дальше", "text": "Теперь вы знаете, как динамическое программирование помогает ускорять решение задач за счёт переиспользования уже найденных ответов. Вы научились формулировать подзадачи, заполнять таблицы и избегать лишних вычислений. Далее — рекурсивные алгоритмы. Мы разберём, как строить решение через самого себя, почему рекурсия бывает полезной и когда она может привести к проблемам. А пока вы не ушли дальше — закрепите материал на практике: Отметьте, что урок прочитан, при помощи кнопки ниже. Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему. Перейдите кзадачамэтого параграфа и потренируйтесь. Перед этим — загляните в короткийгайдо том, как работает система проверки. Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте всообщество Хендбука! Там студенты помогают друг другу разобраться. Динамическое программирование позволяет решать задачи быстрее за счёт повторного использования подзадач. Вместо того чтобы пересчитывать, мы сохраняем уже найденные решения и используем их повторно. Метод особенно полезен, когда подзадачи пересекаются и их много. Иногда универсальный, но медленный алгоритм оказывается практичнее, чем быстрый, но узкоспециализированный.", "useful_links": [{"text": "задачам", "url": "https://new.contest.yandex.ru/contest/79927"}, {"text": "гайд", "url": "https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii"}, {"text": "сообщество Хендбука", "url": "https://t.me/handbook_algorithms"}]}

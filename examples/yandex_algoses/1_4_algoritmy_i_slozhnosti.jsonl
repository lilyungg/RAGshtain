{"document_title": "Алгоритмы и сложность - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/algoritmy-i-slozhnost", "section_title": "Ключевые вопросы параграфа", "text": "Чем задача отличается от её конкретного экземпляра и почему это различие важно? Какие ошибки может допустить алгоритм и как проверить его корректность? В чём преимущества описания алгоритма на псевдокоде? Как измерять «быстроту» алгоритма и почему не всегда важно абсолютное время работы? Почему полиномиальные алгоритмы считаются приемлемыми, а экспоненциальные — проблемными?", "useful_links": []}
{"document_title": "Алгоритмы и сложность - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/algoritmy-i-slozhnost", "section_title": "Что такое алгоритм?", "text": "Алгоритм — это последовательность указаний, которые нужно исполнить, чтобы решить чётко сформулированную задачу. Мы описываем задачи, исходя из ввода и вывода, и алгоритм становится способом превращения ввода в вывод. При этом формулировка задачи должна быть точной и недвусмысленной — это помогает избежать неверной интерпретации. Когда вы закончили проектировать алгоритм, необходимо ответить на два важных вопроса: «Правильно ли он работает?» и «Сколько времени занимает выполнение?». Разумеется, вас не устроит алгоритм, который выдаёт правильный результат лишь в половине случаев или требуетлет для поиска ответа.", "useful_links": []}
{"document_title": "Алгоритмы и сложность - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/algoritmy-i-slozhnost", "section_title": "Псевдокод", "text": "Чтобы понять, как работает алгоритм, нам необходимо перечислить шаги, которые он выполняет. Для этого мы будем использовать псевдокод — язык, которым пользуются разработчики для описания алгоритмов. Он игнорирует многие детали, необходимые в языках программирования, но он более точен, чем рецепт из кулинарной книги.", "useful_links": []}
{"document_title": "Алгоритмы и сложность - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/algoritmy-i-slozhnost", "section_title": "Задача и экземпляр задачи", "text": "Задача описывает класс возможных входных данных. Экземпляр задачи — это один конкретный ввод такого класса. Чтобы продемонстрировать понятия задачи и экземпляра задачи, рассмотрим следующий пример. Вы оказались в книжном магазине и собираетесь купить книгу за, расплатившись купюрой в. Вам должны вернутьцентов в качестве сдачи. Теперь кассир принимает решение, как именно это сделать. Согласитесь, неприятно получить горсть изпенни илиникелей ипенни. Возникает вопрос: как выдать сдачу, не расстроив клиента? Большинство кассиров стараются уместить сумму сдачи в наименьшее количество монет. Пример сцентами представляет собой экземпляр задачиРазмен. Предполагается, что естьноминалов, которые представлены массивом. Для упрощения будем считать, что номиналы даны в порядке убывания. Например,для монет, используемых в США. Переведите определенное количество денег в данные номиналы, используя как можно меньше монет. Входные данные: Целое числои массив изноминаловв порядке убывания (). Выходные данные: Список изцелых чисел, в которомикак можно меньше. Кассиры по всему миру решают эту проблему с помощью простого алгоритма: Скопировать код1Change(money, c, d):2whilemoney >0:3coin = ...// монета с самым большим номиналом, который не превышает money4// дать монету с номиналом coin клиенту5money = money - coin Вот быстрая версия Change: Скопировать код1Change(money, c, d):2fork inrange(1, d +1)3i_k=floor(money / c[k])// наибольшее количество монет номинала c[k]4// дать i_k монет с номиналом c[k] клиенту5money = money - c[k] * i_k", "useful_links": []}
{"document_title": "Алгоритмы и сложность - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/algoritmy-i-slozhnost", "section_title": "Корректные и некорректные алгоритмы", "text": "Мы называем алгоритм корректным, если на каждый получаемый ввод он делает правильный вывод. Алгоритм считается некорректным, если хотя бы один ввод приводит к неправильному выводу. Change— это некорректный алгоритм! Представьте сдачу в 40 центов, выданную в номиналах,,,и. Changeпривел бы к неправильному результату: он выдал бы 1 четвертак (25 центов), 1 дайм (10 центов) и 1 никель (5 центов) вместо 2 монет по двадцать центов. Хоть это и может выглядеть надуманно, в 1875 году в США существовала монета в двадцать центов. Насколько мы можем быть уверены, чтоChangeвыдаст минимальное количество монет в современных номиналах Соединенных Штатов или любой другой страны? Чтобы исправить алгоритмChange, нам нужно рассмотреть все возможные комбинации монет с номиналами, которые дают в сумме, и выдать комбинацию с минимальным количеством монет. Мы рассматриваем только комбинации, в которыхи(в целом, величинане должна превышать), в ином случае мы вернем большее количество денег, чем. В псевдокоде, приведенном ниже, используется символ. Он обозначает суммирование:. Псевдокод также использует концепт «бесконечность» (обозначается) в качестве начального значения для. Реализация описанного подхода на реальных языках программирования может различаться, но сейчас подробности для нас не важны. Скопировать код1BruteForceChange(money, c, d):2smallestNumberOfCoins = ∞3foreach combinations ofcoins(i_1,...,i_d)4// от (0,...,0) до (money/c[1],...,money/c[d])5valueOfCoins = ∑ i_k*c_k// сумма по всем k от 1 до d6ifvalueOfCoins = money:7numberOfCoins = ∑ i_k// суммарное количество монет8ifnumberOfCoins <smallestNumberOfCoins:9smallestNumberOfCoins = numberOfCoins10change = (i_1, i_2, ... ,i_d)11returnchange Цикл повторяется с каждой возможной комбинациейизиндексов и останавливается, когда достигает Как мы можем узнать, чтоBruteForceChangeне содержит ту же проблему, что иChange, — неверный результат при каком-то вводе? РазBruteForceChangeрассматривает все возможные комбинации номиналов, рано или поздно алгоритм придёт к оптимальному решению и запишет его в массив. В любой комбинации монет, которая даёт в сумме, должно быть как минимум столько же монет, сколько и в оптимальной. Таким образом,BruteForceChangeникогда не завершит работу с неоптимальным набором. На данный момент мы ответили только на один из двух важных вопросов об алгоритмах: \"Работает ли он?\". Однако мы не ответили на вопрос: \"Сколько времени занимает выполнение?\".", "useful_links": []}
{"document_title": "Алгоритмы и сложность - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/algoritmy-i-slozhnost", "section_title": "Быстрые и медленные алгоритмы", "text": "Настоящие компьютеры требуют определенное количество времени на выполнение таких операций, как сложение, вычитание или проверка условий цикла while. Суперкомпьютер может выполнить сложение засекунды, а калькулятор — за. Представьте, что у вас есть компьютер, которому требуетсясекунды на выполнение простой операции (например, сложения), и вы знаете, сколько операций выполняет какой-то конкретный алгоритм. Вы могли бы рассчитать время выполнения алгоритма, просто взяв произведение количества операций и времени, которое занимает одна операция. Однако компьютеры постоянно улучшаются, благодаря чему им требуется меньше времени на операцию. Так, ваше представление о времени выполнения быстро стало бы устаревшим. Вместо того, чтобы рассчитывать время выполнения на каждом компьютере, мы описываем время выполнения через общее количество операций, необходимых алгоритму, — это характеристика самого алгоритма, а не компьютера, который вы используете. К сожалению, нам не всегда легко определить, сколько операций выполнит алгоритм. Однако если мы можем рассчитать количество базовых операций, выполняемых алгоритмом, то это позволит сравнить его с другим алгоритмом, решающим ту же задачу. Чтобы мучительно не подсчитывать каждое умножение и сложение, можно сравнивать только те участки кода, которые при увеличении размера ввода потребуют больше операций. Представьте, что алгоритмвыполняетопераций при вводе размера, и алгоритмрешает ту же задачу заопераций. Какой алгоритм быстрее:или? Хотяи может быть быстрее, чем, при более малом значении(например, примежду 1 и 3),будет быстрее при больших значениях(например,). (См. рис.). Так как— это, в каком-то смысле, более «быстрорастущая» функция относительно, чем. При этом константы 3 и 2 вне влияют на конкуренцию между двумя алгоритмами при больших значениях. Мы называемквадратичным алгоритмом и— линейным.менее эффективен, чем, потому что он выполняет больше операций для решения задачи, когда значениебольшое. Так, иногда мы будем допускать неточности при подсчете операций алгоритма: поведение алгоритма при маленьком вводе неважно. Рассчитаем примерное количество операций, которое потребуется дляBruteForceChangeпри вводе изцентов и номиналов. Чтобы рассчитать общее количество операций в цикле for, нам необходимо взять примерное число операций, выполняемое при каждой итерации, и умножить его на общее количество итераций. В нашем случае количество операций можно оценить сверху величиной Такой тип алгоритмов называется экспоненциальным в противоположность квадратичным, кубическим или другим полиномиальным алгоритмам. Выражение времени выполнения экспоненциального алгоритма использует, гдеи— это параметры задачи (например,иможно произвольно сделать большими, изменив ввод для алгоритма). Время выполнения полиномиального алгоритма ограничено, где— это константа, не связанная с тестовыми данными. Например, алгоритм с временем выполнения(линейный),(квадратичный),(кубический) или дажебудет полиномиальным. Конечно, алгоритм с временем выполненияне очень практичен. Возможно, даже менее практичен, чем некоторые экспоненциальные алгоритмы. Впрочем, разработчики тратят много усилий, чтобы проектировать всё более и более быстрые полиномиальные алгоритмы. Раз значениеможет быть большим при вызове алгоритма с большим количеством номиналов (например,), мы видим, что выполнениеBruteForceChangeможет потребовать много времени.", "useful_links": []}
{"document_title": "Алгоритмы и сложность - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/algoritmy-i-slozhnost", "section_title": "Что дальше", "text": "Теперь вы знаете, что такое алгоритм, чем задача отличается от её экземпляра и как алгоритмы помогают решать поставленные задачи. Вы познакомились с псевдокодом, понятием корректности алгоритма и идеей оценки его эффективности. А ещё узнали, почему время выполнения важно и как отличать «быстрые» алгоритмы от «медленных» с точки зрения роста числа операций. А пока вы не ушли дальше — закрепите материал на практике: Отметьте, что урок прочитан, при помощи кнопки ниже. Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему. Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте всообщество Хендбука! Там студенты помогают друг другу разобраться. Алгоритм — это способ преобразования входных данных в выходные. Он решает задачу, формулируемую через множество возможных входов и условий. Псевдокод помогает описывать шаги алгоритма понятно и точно, а корректность означает, что алгоритм всегда выдаёт правильный результат. Эффективность алгоритма оценивается по количеству операций, которые он выполняет, — это позволяет сравнивать алгоритмы независимо от устройства. Полиномиальные алгоритмы масштабируются лучше и считаются эффективными, тогда как экспоненциальные быстро становятся непрактичными при росте входных данных. В следующей главе вы познакомитесь со структурами данных: стеком, очередью, словарём, множеством и списками. Вы узнаете, как они устроены, где используются и чем отличаются друг от друга, — а заодно научитесь применять их в задачах.", "useful_links": [{"text": "сообщество Хендбука", "url": "https://t.me/handbook_algorithms"}]}

{"document_title": "Двоичный поиск - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/dvoichnyj-poisk", "section_title": "Ключевые вопросы параграфа", "text": "Как работает стратегия «Разделяй и властвуй» и как она применяется в двоичном поиске? Почему двоичный поиск так эффективен и в чём его отличие от линейного поиска? Как корректно реализовать двоичный поиск и что важно учесть при работе с границами и условиями?", "useful_links": []}
{"document_title": "Двоичный поиск - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/dvoichnyj-poisk", "section_title": "Разделяй и властвуй", "text": "В этом параграфе вы узнаете об алгоритмах «разделяй и властвуй», которые помогают выполнять поиск по огромным базам данных в миллион раз быстрее, чем алгоритмы исчерпывающего поиска. Вооружившись этой техникой, вы узнаете, что стандартный способ умножать числа (которому вас учили в начальной школе) далеко не самый быстрый. Затем мы применим подход «разделяй и властвуй», чтобы спроектировать быстрые алгоритмы для сортировки. Вы узнаете, что эти алгоритмы оптимальны — то есть даже легендарный ученый Алан Тьюринг не смог бы спроектировать алгоритм сортировки быстрее! Если вы хотите решить задачу с помощью стратегии «разделяй и властвуй», вам нужно подумать о следующих трёх шагах: Разделение задачи на подзадачи поменьше. Рекурсивное решение каждой подзадачи. Объединение выполненных подзадач в решение изначальной задачи. Первые два шага — это и есть «разделяй», а последний — «властвуй». Мы продемонстрируем такой подход в нескольких примерах, сложность которых будет возрастать. Игра «Угадать число» состоит в том, что оппонент загадывает целое число. Вы задаёте вопрос: «?». Оппонент отвечает либо «да», либо «» (то есть «мое число меньше»), либо «» (то есть «мое число больше»). Ваша задача — получить ответ «да», задав минимальное количество вопросов. Пусть: ваша задача — угадать, задав не больше двух вопросов. Вы можете спросить: «?». Если ответ положительный, то вы победили.Но оппонент может ответить: «». Вы решаете, чторавенили, но у вас остаётся только один вопрос. Точно так же вы можете спросить: «?». Тогда ваш оппонент может ответить: «». В этом случае вы не сможете получить желаемый положительный ответ, задав лишь один вопрос. Посмотрим, что будет, если вы сначала спросите: «?». Если оппонент отвечает, что, тогда игра окончена. Если ответ —, то вы уже знаете, что. Следовательно, второй раз вы просто спрашиваете: «?». И теперь вы получаете положительный ответ. Если оппонент ответит, что, то вы спрашиваете: «?». Ответ на него: «Да». Угадать целое число, задав не больше трёх вопросов. Вы уже могли догадаться, что мы начнём с вопроса: «?». Дело в том, что в обоих случаях —и— мы сокращаем пространство поиска с 7 до 3 вариантов (нам уже известно, как решить задачу свозможными вариантами): если, тобудет 1, 2 или 3; если, тобудет 5, 6 или 7. Это означает, что в обоих случаях вы можете воспользоваться решением разобранного ранее случая. Получившийся протокол вопросов показан на рисунке. Следующий код имитирует процесс угадывания. Функцияquery«знает» целое число. Вызовquery(y)сообщает нам:, или, или. Функцияguess()находит числос помощью вызоваquery(). Она вызывается с двумя параметрами:lowerиupper— так, чтобы то естьнаходится в сегменте. Сначала она рассчитывает середину (middle) сегмента, затем вызывает. Если, тогда она продолжает работать с интервалом. Если, тогда она переходит к интервалу. Скопировать код1query(y):2x =16182353ifx == y:4return'equal'5ifx <y:6return'smaller'7else:8return'greater'91011guess(lower, upper):12middle = (lower + upper) /2// целочисленное деление13answer =query(middle)14// можно напечатать запрос и соответствующий результат15ifanswer =='equal':16return17ifanswer =='smaller':18guess(lower, middle -1)19else:20guess(middle +1, upper)212223guess(1,2097151)// начальный возможный диапазон значений Реализуйте этот алгоритм, измените значениеи запустите код, чтобы увидеть последовательность вопросов (удостоверьтесь, чтонаходится в сегменте, который используется при вызовеguess). В целом стратегия, угадывающая целое число, потребует околовопросов. Напомним, чторавняется, если. Это значит, что если мы продолжим делитьна 2, пока не получим 1, будет околоопераций деления. Важно здесь то, что— медленно растущая функция. К примеру, если, то. Метод, который мы использовали для угадывания числа, известен как двоичный поиск. Пожалуй, самый важный случай применения двоичного поиска — это поиск по отсортированным данным. Поиск — фундаментальная задача: имея последовательность и элемент, мы хотим проверить, входит лив последовательность. Например, 3 входит в последовательность, а 4 — не входит. Зная о важности задачи по поиску, неудивительно, что методы для её решения есть почти во всех языках программирования. Скопировать код1print(3in[7,2,5,6,11,3,2,9])2print(4in[7,2,5,6,11,3,2,9]) Что происходит внутри, когда мы вызываем методin? Ожидаемо,Pythonвыполняет линейное сканирование. На это требуетсясравнений при последовательности длиной. Если в последовательность не входит, нам необходимо просканировать все элементы: если мы будем пропускать, то мы не можем точно знать, отсутствует ли. Ситуация кардинально меняется, если полученные данные отсортированы, то есть составляют собой отсортированную последовательностьв порядке возрастания. Оказывается, что в этом случае достаточно околосравнений! Это значительное ускорение: линейный поиск по отсортированному массиву с миллиардом элементов потребует миллиарда сравнений, двоичному же поиску будет достаточно не больше!", "useful_links": []}
{"document_title": "Двоичный поиск - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/dvoichnyj-poisk", "section_title": "Двоичный поиск", "text": "Ваша задача — найти индекс элемента в сортированной последовательности равного. Формат ввода: Отсортированный массивнеповторяющихся целых чисел и целое число. Первые две строки ввода содержат целое числои последовательностьизнеповторяющихся положительных целых чисел в возрастающем порядке. Следующая строка содержит целое число. Формат вывода: Позиция элемента вравногоилипри отсутствии такого элемента. Ограничения:;для всех;. Примеры Можно решить эту задачу примитивным способом — просканировать массив(время выполнения составит). Время решения этой задачи для алгоритмаBinarySearch—. Он инициализируется при присвоениизначения 0 изначения. Сначала алгоритм присваиваетзначение, а затем проверяет, больше, чем, или нет. Еслибольше, чем это значение, тоBinarySearchпроводит итерацию на подмассивеот minIndex до. В ином случае он проводит итерацию на подмассивеотдо. В конечном счёте алгоримт определит, находитсявили нет. Скопировать код1BinarySearch(K[0..n−1], q)2minIndex =03maxIndex = n−14whilemaxIndex >= minIndex:5midIndex = (minIndex+maxIndex) /2// целочисленное деление6ifK[midIndex] = q:7returnmidIndex8elseK[midIndex] <q:9minIndex = midIndex +110else:11maxIndex = midIndex -112return-1 Например, еслии,BinarySearchсначала задаст следующее:,и. Так какбольше, чем, мы рассматриваем подмассив, элементы которого больше, установив, и таким образомперевычисляется как. В этот разменьше, чем, поэтому мы рассматриваем подмассив, элементы которого ниже этого значения. Этот подмассив состоит из одного элемента —. Время выполненияBinarySearchсоставляет, так как алгоритм снижает длину подмассива минимум в два раза при каждой итерации циклаwhile. Дело в том, что любой программе требуется линейное время для чтения данных ввода. По этой причине мы предлагаем вам решить следующую более общую задачу.", "useful_links": []}
{"document_title": "Двоичный поиск - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/dvoichnyj-poisk", "section_title": "Множественный поиск ключей в отсортированной последовательности", "text": "Вывод: При каждомнеобходимо проверить, входит лив. Формат ввода: Отсортированный массивнеповторяющихся целых чисел и массив целых чисел. Первые две строки ввода содержат целое числои последовательностьизнеповторяющихся положительных целых чисел в возрастающем порядке. Следующие две строки содержат целое числоиположительных целых чисел. Формат вывода: Для всехотдовыведите индекс, чтобыилипри отсутствии такого индекса. Ограничения:;;для всех;для всех. Примеры Совет: не используйте встроенный двоичный поиск", "useful_links": []}
{"document_title": "Двоичный поиск - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/dvoichnyj-poisk", "section_title": "Двоичный поиск с дублированием", "text": "Как пишет автор книги «Искусство программирования» Дональд Кнут: «Хотя основная идея двоичного поиска относительно проста, детали могут быть на удивление сложными». Он подразумевает изменённую версию классической задачи двоичного поиска: Когда Кнут попросил профессиональных программистов из таких ведущих компаний, как IBM, реализовать эффективный алгоритм двоичного поиска с дублированием, в 90% из них были баги — год за годом. И правда, хотя первый алгоритм двоичного поиска был опубликован в 1946 году, первый алгоритм для поиска с дублированием, в котором не было багов, впервые опубликовали только в 1962 году. По аналогии с предыдущей задачей здесь мы предлагаем найтицелых чисел, а не одно. Формат ввода: Первые две строки ввода содержат целое числои последовательностьизположительных целых чисел в неубывающем порядке. Следующие две строки содержат целое числоиположительных целых чисел. Формат вывода: Для всехотдовывод индексапервого встречающегося(то есть) или— если такого индекса нет. Ограничения:;;для всех;для всех. Примеры Совет: не используйте встроенный двоичный поиск У вас есть ключи вам необходимо найти первое, самое раннее место, где этот ключ встречается в массиве. Например, еслии ключ— это, тогда первое место, где он встречается, — это индекс. Разумеется, вы можете найти одно из мест, просто начав двоичный поиск. Чтобы найти первое место, где ключ встречается, вы можете последовательно проверять элемент перед позицией того, который был найден, — что и демонстрируется в выделенных голубым строках приведенного ниже псевдокода. Скопировать код1NaiveBinarySearchWithDuplicates(K[0..n−1], q)2minIndex =03maxIndex = n−14whilemaxIndex >= minIndex:5midIndex = (minIndex + maxIndex) /26ifK[midIndex] = q:7top = midIndex8whiletop >0andK[top −1] = K[top]:9top = top -110returntop11ifK[midIndex] <q:12minIndex = midIndex +113else:14maxIndex = midIndex −115return-1 Этот алгоритм может существенно замедлиться при массиве с большим количеством повторов. Например, если повторяющийся элемент занимает половину массива, тоNaiveBinarySearchWithDuplicatesпотребует линейное времявместо логарифмического времени. Эта проблема устранена в псевдокоде ниже. Скопировать код1NaiveBinarySearchWithDuplicates(K[0..n−1], q)2minIndex =03maxIndex = n−14result =-15whilemaxIndex >= minIndex:6midIndex = (minIndex + maxIndex) /27ifK[midIndex] = q:8maxIndex = midIndex -19result = midIndex10elseifK[midIndex] <q:11minIndex = midIndex +112else:13maxIndex = midIndex −114returnresult", "useful_links": []}
{"document_title": "Двоичный поиск - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/dvoichnyj-poisk", "section_title": "Что дальше", "text": "Теперь вы знаете, как работает двоичный поиск — быстрый и надёжный способ находить элементы в отсортированных структурах. Вы научились реализовывать его корректно, аккуратно обращаться с границами и условиями, а также оценивать его эффективность. Далее — задача на определение доминирующего элемента. Представьте, что в базе заказов вам нужно быстро определить, какой товар покупают чаще всего и действительно ли он занимает больше половины всех покупок. Эта задача покажет, как использовать стратегию «Разделяй и властвуй» для анализа последовательностей и комбинировать рекурсию с постобработкой для точного результата. А пока вы не ушли дальше — закрепите материал на практике: Отметьте, что урок прочитан, при помощи кнопки ниже. Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему. Перейдите кзадачамэтого параграфа и потренируйтесь. Перед этим — загляните в короткийгайдо том, как работает система проверки. Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте всообщество Хендбука! Там студенты помогают друг другу разобраться. Двоичный поиск — это способ найти элемент в отсортированной последовательности за логарифмическое время. Корректная реализация требует аккуратной работы с границами, особенно при вычислении середины. Ошибки в условиях цикла или смещении границ — частая причина багов, особенно на больших входах. Двоичный поиск можно адаптировать для решения более сложных задач — например, нахождения первого/последнего вхождения или границы условий.", "useful_links": [{"text": "задачам", "url": "https://new.contest.yandex.ru/contest/80772"}, {"text": "гайд", "url": "https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii"}, {"text": "сообщество Хендбука", "url": "https://t.me/handbook_algorithms"}]}

{"document_title": "Задача «Простой калькулятор» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-prostoj-kalkulyator", "section_title": "Ключевые вопросы параграфа", "text": "Почему жадная стратегия не гарантирует оптимальный результат при построении последовательности операций? Как использовать динамическое программирование для поиска минимального числа шагов? Как восстановить оптимальную последовательность действий из таблицы значений?", "useful_links": []}
{"document_title": "Задача «Простой калькулятор» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-prostoj-kalkulyator", "section_title": "Вводная информация по задаче", "text": "У вас есть калькулятор, который выполняет с целым числомтолько следующие операции: сложитьи, умножитьнаили умножитьна. Имея положительное целое число, вы должны найти минимальное количество операций, необходимых для получения числаиз числа. Попробуем решить эту задачу с помощью «жадной» стратегии: если текущее число не превышает, то умножим его на 3; если оно больше, но не больше, то умножим его на 2; в остальных случаях добавим к нему 1. Это приводит к следующему псевдокоду. Скопировать код1GreedyCalculator(n):2numOperations =03currentNumber =14whilecurrentNumber <n:5ifcurrentNumber <= n/3:6currentNumber =3*currentNumber7elseifcurrentNumber <= n/2:8currentNumber =2*currentNumber9else:10currentNumber =1+currentNumber11numOperations = numOperations+112returnnumOperations Входные данные: Целое число. Выходные данные: В первой строке:— минимальное число необходимых операций для полученияиз. Во второй строке: последовательность промежуточных чисел. Так, вторая строка должна содержать положительные целые числа, при которых,, и для всехравно,или. Если таких последовательностей много, то можно вывести любую из них. Ограничения:. Ещё один корректный вывод в этом случае — это «1 3 9 10 11 33 99 297 891 2673 8019 16038 16039 48117 96234». Рассмотрим решение задачи. Пусть— минимальное количество операций, необходимых для получения числаиз числа. Так как последняя операция в оптимальной последовательности — это «», «» или «», мы получаем следующее рекуррентное соотношение для: Данное рекуррентное соотношение, вместе с базовым случаем, можно трансформировать в рекурсивный, а затем в итерационный алгоритм. Скопировать код1Calculator(n):2table[1..n]←[+infinity,…,+infinity]3table[1] =045fork from2to n:6table[k]=1+table[k−1]7ifk is divisible by2:8table[k]=min(table[k],1+table[k/2])9ifk is divisible by3:10table[k]=min(table[k],1+table[k/3])11returntable[n] Помните, что помимо оптимального значения необходимо вывести оптимальную последовательность операций. Для этого обратим внимание на то, что мы можем найти последнюю операцию следующим образом: это «», если; это «», еслиможно разделить наи; это «», еслиможно разделить наи. Эти действия позволяют нам выявить оптимальную последовательность: найти последнюю операцию; заменитьна,или(в зависимости от того, какой это из трёх случаев выше); повторить (пока). Скопировать код1Calculator(n):2table[1..n]←[+infinity,…,+infinity]3table[1] =045fork from2to n:6table[k]=1+table[k−1]7ifk is divisible by2:8table[k]=min(table[k],1+table[k/2])9ifk is divisible by3:10table[k]=min(table[k],1+table[k/3])1112operations = empty list13whilen >1:14append n to operations15iftable[n]=1+table[n−1]:16n = n -117elseifn is divisible by2andtable[n]=1+table[n/2]:18n = n/219elseifn is divisible by3andtable[n]=1+table[n/3]:20n = n/321returnoperations Время выполнения алгоритма составляет.", "useful_links": []}
{"document_title": "Задача «Простой калькулятор» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-prostoj-kalkulyator", "section_title": "Что дальше", "text": "Теперь вы знаете, как находить минимальную последовательность операций для получения заданного числа, используя динамическое программирование. Вы научились строить таблицу значений и восстанавливать по ней путь — от цели к началу. А ещё убедились, что жадный подход может подвести, даже если кажется логичным. Далее — задача на редактирование строк. Вы узнаете, как рассчитать расстояние между двумя строками, используя матрицу изменений, и зачем это нужно в задачах на сравнение, поиск и коррекцию. А пока вы не ушли дальше — закрепите материал на практике: Отметьте, что урок прочитан, при помощи кнопки ниже. Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему. Перейдите кзадачамэтого параграфа и потренируйтесь. Перед этим — загляните в короткийгайдо том, как работает система проверки. Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте всообщество Хендбука! Там студенты помогают друг другу разобраться. Жадный алгоритм может не давать оптимальный результат — даже если кажется разумным. Динамическое программирование позволяет найти кратчайшую последовательность операций с минимальными затратами. Чтобы восстановить путь, нужно не только посчитать значения, но и зафиксировать переходы. Умение строить такие цепочки важно для задач, где нужно не только посчитать, но и объяснить, как получить ответ.", "useful_links": [{"text": "задачам", "url": "https://new.contest.yandex.ru/contest/80778"}, {"text": "гайд", "url": "https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii"}, {"text": "сообщество Хендбука", "url": "https://t.me/handbook_algorithms"}]}

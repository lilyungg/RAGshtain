[
  {
    "document_title": "Рандомизированные алгоритмы - Основы алгоритмов",
    "url": "https://education.yandex.ru/handbook/algorithms/article/randomizirovannye-algoritmy",
    "section_title": "Ключевые вопросы параграфа",
    "text": "Что такое рандомизированные алгоритмы и как они работают? В чём разница между худшим и ожидаемым временем выполнения? Зачем алгоритмам случайность и когда она даёт преимущество?",
    "useful_links": []
  },
  {
    "document_title": "Рандомизированные алгоритмы - Основы алгоритмов",
    "url": "https://education.yandex.ru/handbook/algorithms/article/randomizirovannye-algoritmy",
    "section_title": "Что такое рандомизированные алгоритмы",
    "text": "Если у вас есть монетка, то прежде чем начать искать телефон, вы можете подбросить её и решить, откуда начать поиск: если выпадет решка, то сначала ищем на первом этаже, если орёл — на втором. А для выбора конкретной комнаты можно использовать игральный кубик. Хотя бросать монеты и кубики весело, этот подход однозначно не интуитивен. К тому же непонятно, даёт ли это алгоритмическое преимущество по сравнению с детерминированным алгоритмом. Наши задачи помогут разобраться, в каких ситуациях вероятностные алгоритмы будут лучше детерминированных. Чтобы продемонстрировать пример вероятностного алгоритма, обсудим сначала быстрый метод сортировки, который называетсяQuickSort. Для упрощения будем считать, что все элементы данного массиваразные. QuickSortвыбирает элемент(например, первый) изи просто разделяет массив на два подмассива:, в который входят все элементыменьше; и, в который входят все элементы больше. Это разделение можно выполнить за линейное время, далее, следуя стратегии «разделяй и властвуй»,QuickSortрекурсивно сортирует каждый подмассив. Итоговый отсортированный список может быть легко получен с помощью конкатенации отсортированного, элементаи отсортированного. Скопировать код1QuickSort(c):2if|c| =1:// только один элемент3returnc4m = c[1]// возьмем первый элемент c5// определим элементы c_small меньше m6// определим элементы c_large больше m7QuickSort(c_small)8QuickSort(c_large)9// объединим c_small, m и c_large в сортированный список c_sorted10returnc_sorted Для данного подхода требуется выделить дополнительную память, в которой будут храниться массивыи. Лучший подход — переставить элементы входного массива на месте, чтобы наборшёл первым, затем, а затем(см. ниже) — однако неясно, как это сделать. Нико Ломуто предложил изящный алгоритм, позволяющий выполнить такую перестановку элементов на месте. Рисунок ниже показывает, как работает разбиение Ломуто. Посмотрите на рисунок. Сможете ли вы воссоздать логику подхода Ломуто? Оказывается, что время выполненияQuickSortзависит от нашей удачи при отборе элемента. Если мы выберемтак, что массивразделяется на две равные части (то есть), тогда гдеозначает время, которое требуетсяQuickSortдля сортировки массива изчисел, иозначает время, которое потребуется для разделения массива длинына две части;— положительная константа. Это абсолютно такое же рекуррентное соотношение, как и вMergeSort, соответствующее времени выполнения. Тем не менее если мы выберемтак, чторазделится неровно (например, возникает крайний случай, когда наборпуст, а в набореэлементов), тогда рекуррентное соотношение будет Это соотношение и приводит к времени выполнения, а этого мы пытаемся избежать. Сортировка массивас помощьюQuickSortдействительно занимает квадратичное время. Что ещё хуже, на обработкутребуется время. Это выглядит излишним, ведь массив уже отсортирован. Пока что алгоритмQuickSortпохож на плохую имитациюMergeSort. Однако если мы сможем выбрать хороший «разделитель», который разбивает массив на две равные части, мы сможем улучшить время выполнения. На самом деле, не обязательно пытаться достичь идеального разделения (50/50), чтобы получить время выполнения. Например, также подойдет разделение на примерно равные части (скажем, 51/49). Фактически можно доказать, что алгоритм будет иметь время выполненияпри условии, что оба набораибольше, чем. Из этого следует, что извозможных вариантов для, выбранного в качестве элементов массива, как минимумхорошо подойдут для разделения! Другими словами, если мы возьмемслучайным образом (вероятность выбрать любой из элементоводинакова), то у нас будет шанс 50% получить хорошее разделение. Такой вывод ложится в основу следующего вероятностного алгоритма: Скопировать код1RandomizedQuickSort(c):2if|c| =1:// только один элемент3returnc4m = ...// возьмем случайный элемент из c5// определим элементы c_small меньше m6// определим элементы c_large больше m7RandomizedQuickSort(c_small)8RandomizedQuickSort(c_large)9// объединим c_small, m и c_large в сортированный список c_sorted10returnc_sorted На практикеRandomizedQuickSort— это быстрый алгоритм. Однако его худшее время выполнения остается, так как все еще есть вероятность, что он выберет плохой разделитель. При одном и том же вводе поведение вероятностного алгоритма отличается от одного выполнения к другому. Тем не менее мы можем доказать, что его ожидаемое время выполнения —. Слово «ожидаемое» подмечает следующий эффект. Так какRandomizedQuickSort— это вероятностный алгоритм, два разных запуска (при одинаковом вводе) могут занять разное количество времени: некоторые будут быстрыми, некоторые — медленными. Таким образом, время выполнения вероятностного алгоритма — это случайная величина. Разработчики нередко интересуются средним значением этой случайной величины, что и называется ожидаемым временем выполнения. Можно продемонстрировать, что для каждого массива размером вожидаемое время выполненияRandomizedQuickSortбудет.",
    "useful_links": []
  },
  {
    "document_title": "Рандомизированные алгоритмы - Основы алгоритмов",
    "url": "https://education.yandex.ru/handbook/algorithms/article/randomizirovannye-algoritmy",
    "section_title": "Преимущество вероятностных алгоритмов",
    "text": "Главное преимущество вероятностных алгоритмов — это производительность. Вероятностные алгоритмы решают многие реальные задачи быстрее (с точки зрения ожидаемого времени выполнения), чем детерминированные алгоритмы. Еще одна привлекательная особенность — это их простота. Она демонстрируется, например, вRandomizedQuickSort. Мы подчеркиваем, что хотяRandomizedQuickSortи принимает решения случайным образом, он всегда выдаёт правильное решение задачи сортировки. Единственный изменяющийся параметр от одного прогона к другому — это время выполнения, но не результат. В противоположность этому, другие вероятностные алгоритмы обычно приводят к неправильным (или точнее, приблизительным) решениям. Вероятностные алгоритмы, которые всегда дают верные решения, называются «Лас-Вегас». Алгоритмы, которые не приводят к верным решениям — «Монте-Карло».",
    "useful_links": []
  },
  {
    "document_title": "Рандомизированные алгоритмы - Основы алгоритмов",
    "url": "https://education.yandex.ru/handbook/algorithms/article/randomizirovannye-algoritmy",
    "section_title": "Что дальше",
    "text": "Теперь вы познакомились с разными подходами к построению алгоритмов — от рекурсии до динамического программирования, от «Разделяй и властвуй» до рандомизированных стратегий. Вы научились оценивать, насколько эффективен алгоритм, и выбирать подходящий метод в зависимости от задачи. В следующем параграфе мы подведём итоги и сравним основные стратегии: где срабатывает жадность, где помогает случайность, а где лучше хранить промежуточные результаты. Это поможет вам научиться видеть за конкретной задачей типовую структуру — и сразу подбирать подходящий алгоритм. А пока вы не ушли дальше — закрепите материал на практике: Отметьте, что урок прочитан, при помощи кнопки ниже. Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему. Перейдите кзадачамэтого параграфа и потренируйтесь. Перед этим — загляните в короткийгайдо том, как работает система проверки. Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте всообщество Хендбука! Там студенты помогают друг другу разобраться. Рандомизированные алгоритмы используют случайность для ускорения решения задач. Алгоритм RandomizedQuickSort в среднем работает за O(n log n), хотя в худшем случае даёт O(n²). Ожидаемое время выполнения может быть надёжным ориентиром, даже если поведение алгоритма меняется от запуска к запуску.",
    "useful_links": [
      {
        "text": "задачам",
        "url": "https://new.contest.yandex.ru/contest/79936"
      },
      {
        "text": "гайд",
        "url": "https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii"
      },
      {
        "text": "сообщество Хендбука",
        "url": "https://t.me/handbook_algorithms"
      }
    ]
  }
]
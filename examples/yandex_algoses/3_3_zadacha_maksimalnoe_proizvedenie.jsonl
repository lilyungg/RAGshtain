{"document_title": "Задача «Максимальное произведение» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie", "section_title": "Ключевые вопросы параграфа", "text": "Почему наивное решение не всегда укладывается в ограничение по времени? Как реализовать быстрый и надёжный алгоритм для вычисления максимального попарного произведения? Зачем нужно стресс-тестирование и как оно помогает найти ошибки, незаметные при обычной проверке?", "useful_links": []}
{"document_title": "Задача «Максимальное произведение» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie", "section_title": "Разбор задачи", "text": "Разберём чуть более сложную задачу. Итак, вам дана последовательность неотрицательных целых чисел. Вычислите Обратите внимание, чтоидолжны быть разными, хотя в каких-то случаях можно наблюдать, что. Формат ввода: Первая строка содержит целое число. Следующая строка содержитнеотрицательных целых чисел(разделены пробелами). Формат вывода: Максимальное попарное произведение. Ограничения:;. Примеры", "useful_links": []}
{"document_title": "Задача «Максимальное произведение» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie", "section_title": "Наивный подход", "text": "Наивный способ решить задачуМаксимальное произведение— перебрать все возможные пары вводных элементови найти пару, которая даёт наибольшее произведение. Скопировать код1MaxPairwiseProductNaive(A[1..n]):2product =03fori from1to n4forj from1to n5ifi != j6ifproduct <A[i] * A[j]7product = A[i] * A[j]8returnproduct Этот код можно оптимизировать и сократить следующим образом. Скопировать код1MaxPairwiseProductNaive(A[1..n]):2product =03fori from1to n4forj from i+1to n5product =max(product, A[i] * A[j])6returnproduct Реализуйте этот алгоритм, используя ваш любимый язык программирования. Если вы используетеC++,JavaилиPython3, вам могут пригодиться начальные заготовки (для всех задач из хендбука мы предлагаем стартовые заготовки с использованием этих трёх языков в интерфейсе тестирующей системы). С другими языками вам понадобится сделать работу с нуля. Стартовые заготовки решений дляC++,JavaиPython3представлены ниже. Скопировать код1#include<iostream >2#include<vector >3#include<algorithm >45intMaxPairwiseProduct(conststd::vector <int>&numbers){6intmax_product =0;7intn = numbers.size();89for(intfirst =0; first <n; ++first) {10for(intsecond = first +1; second <n; ++second) {11max_product = std::max(max_product,12numbers[first] * numbers[second]);13}14}1516returnmax_product;17}1819intmain(){20intn;21std::cin >>n;22std::vector <int>numbers(n);23for(inti =0; i <n; ++i) {24std::cin >>numbers[i];25}2627std::cout <<MaxPairwiseProduct(numbers) <<\"\\n\";28return0;29} Скопировать код1importjava.util.*;2importjava.io.*;34publicclassMaxPairwiseProduct{5staticintgetMaxPairwiseProduct(int[] numbers){6intmax_product=0;7intn=numbers.length;89for(intfirst=0; first <n; ++first) {10for(intsecond=first +1; second <n; ++second) {11max_product = Math.max(max_product,12numbers[first] * numbers[second]);13}14}1516returnmax_product;17}1819publicstaticvoidmain(String[] args){20FastScannerscanner=newFastScanner(System.in);21intn=scanner.nextInt();22int[] numbers =newint[n];23for(inti=0; i <n; i++) {24numbers[i] = scanner.nextInt();25}26System.out.println(getMaxPairwiseProduct(numbers));27}2829staticclassFastScanner{30BufferedReader br;31StringTokenizer st;3233FastScanner(InputStream stream) {34try{35br =newBufferedReader(new36InputStreamReader(stream));37}catch(Exception e) {38e.printStackTrace();39}40}4142Stringnext(){43while(st ==null|| !st.hasMoreTokens()) {44try{45st =newStringTokenizer(br.readLine());46}catch(IOException e) {47e.printStackTrace();48}49}50returnst.nextToken();51}5253intnextInt(){54returnInteger.parseInt(next());55}56}5758} Скопировать код1defmax_pairwise_product(numbers):2n =len(numbers)3max_product =04forfirstinrange(n):5forsecondinrange(first +1, n):6max_product =max(max_product,7numbers[first] * numbers[second])89returnmax_product101112if__name__ =='__main__':13_ =int(input())14input_numbers =list(map(int,input().split()))15print(max_pairwise_product(input_numbers)) После проверки вы можете увидеть такое сообщение: Дело в том, что мы проверяем ваше решение на тестовых примерах — это помогает убедиться, что программа работает быстро и без ошибок. В результате мы, как правило, знаем, какие ошибки вы допустили. Сообщение выше говорит о том, что предложенная программа превышает ограничение по времени в 4-м тестовом примере из 17. MaxPairwiseProductNaiveвыполняет порядкашагов при последовательности длиной. При максимальном возможном значенииколичество шагов будет порядка. Так как большинство современных компьютеров выполняют около–базовых операций в секунду (разумеется, это зависит от компьютера), выполнениеMaxPairwiseProductNaiveможет занять десятки секунд. Это превысит временное ограничение задачи. Нам нужен более быстрый алгоритм!", "useful_links": []}
{"document_title": "Задача «Максимальное произведение» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie", "section_title": "Быстрый алгоритм", "text": "А что если внимательнее рассмотреть более мелкие примеры— скажем,? Эврика! Достаточно помножить два самых больших элемента массива —и. То есть нам достаточно просканировать последовательность лишь дважды. При первом сканировании мы найдем самый большой элемент, затем — второй по величине. Скопировать код1MaxPairwiseProductFast(A[1..n]):2index_1 =13fori from2to n4ifA[i] >A[index_1]5index_1 = i6index_2 =17fori from2to n8ifA[i] != A[index_1]andA[i] >A[index_2]9index_2 = i10returnA[index_1] * A[index_2]", "useful_links": []}
{"document_title": "Задача «Максимальное произведение» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie", "section_title": "Тестирование и отладка", "text": "Реализуйте этот алгоритм и протестируйте его на вводе. Как и ожидалось, алгоритм выводит. Затем проверьте на вводе. На удивление, алгоритм выводит. Изучив код, вы обнаружите, что после первого цикла. Далее алгоритм инициализируетзначением, и цикл for не обновляет. В результате перед возвратом. Чтобы этого избежать, необходимо изменить псевдокод следующим образом: Скопировать код1MaxPairwiseProductFast(A[1..n]):2index_1 =13fori from2to n4ifA[i] >A[index_1]:5index_1 = i6ifindex_1 =17index_2 =28else:9index_2 =110fori from1to n11ifA[i] != A[index_1]andA[i] >A[index_2]12index_2 = i13returnA[index_1] * A[index_2] Опробуйте этот код на маленьких наборах данных, чтобы убедиться, что он выдает правильные результаты. Затем попробуйте ввод. Может оказаться, что программа выдает что-то вродеили даже отрицательное число вместо правильного результата —. Вероятнее всего, это вызвано целочисленным переполнением. Например, на языкеC++такое большое число, как, не умещается в стандартный типint, который занимает 4 байта на большинстве компьютеров и варьируется отдопри Соответственно, вместо использования типаintвC++при вычислении произведения и сохранении результата вам нужно использовать типint64_t. Это предотвратит целочисленное переполнение, так как типint64_tзанимает 8 байтов и хранимые значения варьируются отдопри Протестируйте вашу программу с большими наборами данных, например с массивом, гдедля всех. Это можно сделать двумя способами: Создать массив в программе и передать егоMaxPairwiseProductFast(чтобы не считывать его из стандартного ввода). Создать отдельную программу, которая запишет такой массив в файлdataset.txt. Затем передать этот набор данных вашей программе из консоли: Убедитесь, что при обработке данных ваша программа укладывается в ограничение по времени и выдаёт верный результат:. Теперь вы можете быть уверенным, что ваша программа работает! Однако система оценки снова ругается: Но как создать такой тестовый сценарий, который приведет к сбою программы и поможет понять, что с ней не так? Вероятно, вас интересует, почему мы не предоставили 5-й набор данных из 17 — тот, который привел к сбою программы? Причина проста: в реальности вам не будут показывать тестовые примеры. Даже опытные программисты при решении задач с алгоритмами часто совершают ошибки, которые трудно обнаружить. Поэтому важно научиться находить баги как можно раньше. Когда авторы этой книги только начинали программировать, они ошибочно полагали, что почти все их программы правильные. Сейчас же мы знаем, что при первом запуске наши программы почти никогда не верны. Когда разработчик уверен в работе своей программы, он зачастую использует всего лишь несколько примеров для тестирования. Если результаты выглядят приемлемо, он считает свою работу законченной — но это путь к катастрофе. Если вы хотите убедиться, что ваша программа работает всегда, то советуем тщательно подобрать примеры для тестирования. Реализация алгоритмов, а также их тестирование и отладка будут бесценным навыком для вашей будущей карьеры программиста. Представляем вам стресс-тестирование — технику, которая позволяет генерировать тысячи тестовых сценариев. С её помощью можно найти тот, из-за которого провалилось ваше решение. Стресс-тестирование состоит из четырёх частей: Реализация алгоритма. Альтернативная, банальная и медленная, но правильная реализация алгоритма для той же самой задачи. Генератор случайных тестов. Бесконечный цикл, генерирующий тесты и передающий их обоим вариантам реализации для сравнения результатов. Если результаты разнятся, выводятся оба результата и пример для тестирования, а программа останавливается. В ином случае цикл повторяется. Стресс-тестирование основано на идее, что две правильных реализации с каждым тестом должны приводить к одному ответу (при условии, что ответ на задачу уникален). Однако если одна из реализаций неправильна, должен существовать такой тест, который приводит к разным ответам. Единственный случай, при котором это не так, — когда в обеих реализациях есть одна и та же ошибка. Но это маловероятно — если ошибка не где-то в программе ввода/вывода, общей для обоих решений. Действительно, если одно решение правильно, а другое — нет, то существует сценарий тестирования, при котором они различаются. Если оба решения неверны, но баги отличаются — скорее всего, есть тест, при котором два решения дают разные результаты. Продемонстрируем стресс-тестированиеMaxPairwiseProductFast, используя MaxPairwiseProductNaiveв качестве тривиальной реализации: Скопировать код1StressTest(N, M):2whiletrue:3n = ...// случайное целое число между 2 и N4// создать массив A[1..n]5fori from1to n6A[i] = ...// случайное целое число между 0 и M7print(A[1..n])8result_1 =MaxPairwiseProductNaive(A)9result_2 =MaxPairwiseProductFast(A)10ifresult_1 = result_2:11print(\"OK\")12else:13print(\"Wrong answer:\", result_1, result_2)14return Представленный выше циклwhileсначала генерирует длину вводной последовательности, случайное число междуи. Оно должно быть не менее: формулировка задачи гласит, что. Параметрдолжен быть достаточно маленьким, чтобы позволить нам рассмотреть множество тестов, несмотря на то, что наши решения медленные. Сгенерировав, мы генерируем массивсцелыми числами отдои выводим его, чтобы по ходу бесконечного цикла мы всегда знали, какой тест проходит сейчас. Это упростит нахождение ошибок в коде для генерации теста. Затем мы вызываем два алгоритма дляи сравниваем результаты. Если результаты отличаются, мы их печатаем и останавливаемся. В ином случае мы продолжаем цикл while. Давайте запустимStressTest(10, 100'000)и скрестим пальцы в надежде, что он выдастWrong answer. Для нас это выглядит как-то так (результат может отличаться на вашем компьютере из-за другого генератора случайных чисел). Ура! Мы нашли пример, в которомMaxPairwiseProductNaiveиMaxPairwiseProductFastприводят к разным результатам, и теперь можем проверить, что именно пошло не так. Затем мы отлаживаем это решение через этот пример, находим баг, исправляем его и повторяем стресс-тестирование. Обратите внимание, что генерировать тесты автоматически и проводить стресс-тестирование легко, но находить и исправлять баги — сложно. Прежде чем углубиться в отладку багов, давайте попробуем сгенерировать тестовый пример поменьше — это упростит нам работу. Для этого мы поменяемс 10 на 5 исна. Затем мы заново начинаем стресс-тестирование и получаем следующее: Медленный алгоритмMaxPairwiseProductNaiveдаёт верный ответ(), но быстрыйMaxPairwiseProductFast— неверный (). Чтобы избавиться от багов в первом решении, давайте проверим, какие два числа он считает наибольшими. Для этого мы добавим следующую строку передreturnв функцииMaxPairwiseProductFast: Скопировать код1print(index_1, index_2) Когда мы снова начинаем стресс-тестирование, мы получаем следующее: Это значит, что последовательность выглядит случайной, но она одинакова каждый раз, когда работает программа. Такое свойство удобно и важно. Советуем вам использовать эту практику, потому что в детерминированных программах (тех, что всегда выдают одинаковый результат при одинаковых вводных данных) легче находить баги, чем в недетерминированных. Давайте теперь рассмотрими. Если мы обратим внимание на код для определения второго максимального числа, то заметим неочевидный баг. Когда мы использовали условие для(число не должно быть таким же, как предыдущее самое большое), вместо сравненияимы сравнилии. Это означает, что второе максимальное число отличается от первого по значению, а не по индексу элемента, который мы выбрали для решения задачи. Так, наше решение не работает при любом тесте, в котором второе самое большое число равно первому. Теперь изменим условие: вместо Скопировать код1A[i] != A[index_1] мы используем Скопировать код1i != index_1 Проведя стресс-тестирование еще раз, мы видим на экране шквал сообщенийOK. Ждём минуту, пока нам не надоест, и заключаем, чтоMaxPairwiseProductFastнаконец-то работает правильно! Однако не стоит останавливаться на этом, так как вы сгенерировали только очень маленькие тесты си. Теперь нужно проверить, работает ли наша программа при большеми бо́льших элементах массива. Таким образом, мы меняемна(при большемпримитивное решение будет довольно медленным из-за квадратичного времени выполнения). Мы также меняемнаи запускаем программу. Ещё раз наблюдаем, как экран заполняется сообщениямиOK. Затем ждём минуту, а потом решаем, чтоMaxPairwiseProductFastдействительно работает верно. После этого мы сдаём получившееся решение системе оценки и успешно проходим тест! Как вы можете заметить, даже при решении такой простой задачи какМаксимальное попарное произведениесложно избежать труднораспознаваемых ошибок на этапе проектирования и реализации алгоритма. Приведённый ниже псевдокод — это пример болеенадежногоспособа реализации алгоритма. Скопировать код1MaxPairwiseProductFast(A[1..n]):2index =13fori from2to n4ifA[i] >A[index]:5index = i6swap(A[index], A[n])// поставим наибольшее значение в конец массива7index =1:8fori from2to n -19ifA[i] >A[index]:10index = i11swap(A[index], A[n -1])// поставим второй по величине элемент предпоследним12returnA[n -1] * A[n] В этом хендбуке вы узнаете, как проектировать и реализовывать алгоритмы так, чтобы минимизировать вероятность ошибок. А заодно научитесь тестировать вашу реализацию.", "useful_links": []}
{"document_title": "Задача «Максимальное произведение» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie", "section_title": "Ещё более быстрый алгоритм", "text": "АлгоритмMaxPairwiseProductFastнаходит два самых больших числа примерно засравнений. Когда вы решите эту задачу, вас ждет ещё более сложное упражнение. Попробуйте с ним справиться! Если это упражнение показалось вам слишком простым, посмотрите задачи ниже. Они вполне могут оказаться на следующем собеседовании! Докажите, что не существует алгоритма, которому потребуется менеесравнений, чтобы найти два самых больших элемента массива. Какой алгоритм найдёт три самых больших элемента быстрее всего?", "useful_links": []}
{"document_title": "Задача «Максимальное произведение» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie", "section_title": "Более компактный алгоритм", "text": "ЗадачуМаксимальное попарное произведениеможно решить с помощью следующего компактного алгоритма, который использует сортировку (в неубывающем порядке). Скопировать код1MaxPairwiseProductBySorting(A[1..n]):2Sort(A)3returnA[n-1]*A[n] Этот алгоритм делает даже больше, чем нам нужно: вместо того, чтобы найти два самых больших элемента, он сортирует весь массив. Поэтому его время выполнения, а не. Однако для таких ограничений () он достаточно быстрый, чтобы выполнить задачу за секунду и успешно пройти тесты в нашей системе оценки.", "useful_links": []}
{"document_title": "Задача «Максимальное произведение» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie", "section_title": "Что дальше", "text": "Теперь вы увидели, как задача на попарное произведение помогает отработать сразу несколько важных умений: оценку сложности алгоритма, поиск оптимального решения, работу с переполнением и стресс-тестирование. Вы научились сравнивать наивные и быстрые реализации, находить баги и проверять программу на надёжность с помощью генератора случайных тестов. Далее — небольшой параграф с итогами: вспомним, что вы узнали в этой главе, и наметим, куда двигаться дальше. А пока закрепите материал на практике: Отметьте, что урок прочитан, при помощи кнопки ниже. Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему. Перейдите кзадачамэтого параграфа и потренируйтесь. Перед этим — загляните в короткийгайдо том, как работает система проверки. Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте всообщество Хендбука! Там студенты помогают друг другу разобраться. Даже в простой на первый взгляд задаче важно учитывать эффективность: наивный перебор может не уложиться в ограничение по времени. Быстрый алгоритм позволяет решить задачу линейно, но требует аккуратности в работе с индексами и типами данных. Стресс-тестирование помогает находить ошибки, которые не видны на демонстрационных примерах, и делает решение по-настоящему надёжным.", "useful_links": [{"text": "задачам", "url": "https://new.contest.yandex.ru/contest/80762"}, {"text": "гайд", "url": "https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii"}, {"text": "сообщество Хендбука", "url": "https://t.me/handbook_algorithms"}]}

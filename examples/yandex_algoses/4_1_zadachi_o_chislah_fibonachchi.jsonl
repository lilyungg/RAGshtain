{"document_title": "Задачи о числах Фибоначчи - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadachi-o-chislah-fibonachchi", "section_title": "Ключевые вопросы параграфа", "text": "Как устроены числа Фибоначчи и какие есть способы их вычисления? Почему важно учитывать время выполнения, типы данных и переполнение даже в простых задачах? Что такое период Пизано и как он помогает находить остатки от огромных чисел Фибоначчи?", "useful_links": []}
{"document_title": "Задачи о числах Фибоначчи - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadachi-o-chislah-fibonachchi", "section_title": "Числа Фибоначчи", "text": "Прежде чем начать, коротко напомним, что числа Фибоначчи — числовой ряд, при котором каждое последующее число равно сумме двух предыдущих. Такие числа определяются рекурсивно: Это приводит к следующему рекурсивному алгоритму: Скопировать код1Fibonacci(n):2ifn <=1:3returnn4else:5returnFibonacci(n−2)+Fibonacci(n−1) Рассмотрим совсем простую задачу. Входные данные: Целое число. Выходные данные:. Ограничения:. Примеры Ниже мы описываем простую реализацию рекурсивного псевдокода дляPython. В неё входит инструкция по обнаружению багов, которая выводит то, что вычисляется в данный момент. Мы пробуем вычислитьс помощью этого кода. Скопировать код1deffibonacci(n):2ifn <=1:3returnn4else:5print(f'Computing F{n}recursively...')6returnfibonacci(n -2) + fibonacci(n -1)789print(fibonacci(7)) Скопировать код1Computing F7 recursively...2Computing F5 recursively...3Computing F3 recursively...4Computing F2 recursively...5Computing F4 recursively...6Computing F2 recursively...7Computing F3 recursively...8Computing F2 recursively...9Computing F6 recursively...10Computing F4 recursively...11Computing F2 recursively...12Computing F3 recursively...13Computing F2 recursively...14Computing F5 recursively...15Computing F3 recursively...16Computing F2 recursively...17Computing F4 recursively...18Computing F2 recursively...19Computing F3 recursively...20Computing F2 recursively...2113 Как видите, код даёт нам верный результат (), но многие вычисления повторяются. Если вы решите вычислитьс помощью этого кода, то Солнце потухнет раньше, чем компьютер выдаст вам результат. Скорее всего вы бы взяли лист бумаги и написали что-то вроде: Вполне разумно попросить компьютер вычислитьтаким жеитерационнымспособом: Скопировать код1Fibonacci(n):2ifn <=1:3returnn4allocate an array F[0..n]5F[0] =06F[1] =17fori from2to n:8F[i] = F[i −2] + F[i −1]9returnF[n] Приблизительное количество операций, необходимых алгоритму, —. Этот алгоритм хорошо работает на практике. Как вы могли заметить, нет необходимости хранить все числа последовательности Фибоначчи: чтобы вычислить текущее число, достаточно знать два предыдущих. Скопировать код1Fibonacci(n):2ifn <=1:3returnn4previous =05current =16foriter inrange(n-1):7oldPrevious = previous8previous = current9current = oldPevious + previous10returncurrent Рекурсивный алгоритм требует так много времени, потому что он повторяет множество одинаковых вычислений: напримерFibonacci(7)вызываетFibonacci(3)пять раз. Не проще ли сохранить, как только это значение вычислено, и при необходимости использовать сохранённое значение вместо того, чтобы вычислять его с нуля? Такой простой подход называется «мемоизация» — при вычислении чего-либо сохраните это в структуре данных, чтобы избежать повторных вычислений в будущем. Давайте добавим мемоизацию в рекурсивный алгоритм, чтобы сделать его практичнее. Скопировать код1table — некоторый ассоциативный контейнер (в table[i] будем сохранять F[i])23Fibonacci(n):4iftable[n] ещё не вычисляли:5ifn <=1:6table[n] = n7else:8table[n] =Fibonacci(n−2)+Fibonacci(n−1)9returntable[n] По сравнению с изначальным рекурсивным алгоритмом этот сделает максимум«серьёзных» рекурсивных вызовов: для каждогопервый вызовFibonacci(i)вычисляет, сохраняя в; затем все дальнейшие вызовыFibonacci(i)становятся просто поиском по таблице.", "useful_links": []}
{"document_title": "Задачи о числах Фибоначчи - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadachi-o-chislah-fibonachchi", "section_title": "Последняя цифра числа Фибоначчи", "text": "Формат ввода: Целое число. Формат вывода: Последняя цифра. Ограничения:. Примеры Для решения этой задачи мы вычислими просто выведем последнюю цифру последовательности: Скопировать код1FibonacciLastDigit(n):2ifn <=1:3returnn4F[0..n] — массив для промежуточных значений5F[0] =06F[1] =17fori from2to n:8F[i] = F[i −1] + F[i −2]9returnF[n] mod10 Таким образом, если вы используете типы C++int32илиint64для хранения, вы быстро придёте к целочисленному переполнению. Если вы используете числа произвольной точности, например,BigIntegerв Java или встроенные целые числа в Python, то вы заметите, что цикл проходит намного медленнее при повышающемся числе итераций. Несложно увидеть, что последняя цифра вравна, и она полностью определена последними цифрами ви. Это подсказывает нам, как сделать алгоритм практичнее: вместо вычисленияи использования последней цифры можно взять каждое промежуточное звено по модулю 10. Главный посыл этой задачи: когда вам нужно вычислить результат последовательности арифметических операций по модулю, берите результат каждой операции по модулю. Так можно гарантировать, что числа, с которыми вы работаете, будут маленькими (они уместятся в стандартный тип языка программирования, который вы предпочитаете) и что арифметические операции с ними будут выполняться быстро. Скопировать код1FibonacciLastDigit(n):2ifn <=1:3returnn4F[0..n] — массив для промежуточных значений5F[0] =06F[1] =17fori from2to n:8F[i] = (F[i −1] + F[i −2]) mod109returnF[n]", "useful_links": []}
{"document_title": "Задачи о числах Фибоначчи - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadachi-o-chislah-fibonachchi", "section_title": "Огромное число Фибоначчи", "text": "Формат ввода:Целые числаи. Формат вывода:. Ограничения:,. Примеры Предупреждение: . . содержит миллионы цифр, но. В этой задачеможет быть настолько большим, что алгоритму потребуется слишком много времени, чтобы пройти через все числа Фибоначчидляотдо. Чтобы понять, как решить эту задачу, не проходя через все числа, взгляните на таблицу ниже: Обе эти последовательности — периодические! Период для—. Его длина —. Дляпериод будет, и его длина —. В итоге, чтобы вычислить, например,, нам понадобится найти остальную частьпри делении на. Так как, мы можем заключить, что. Оказывается, что для любого целого числапоследовательностьбудет периодической. Период всегда начинается с. Он называется «период Пизано» (Фибоначчи также называют «Пизано»). Каким будет период? Докажите, что для каждого числапоследовательностьбудет периодической. Докажите, что период последовательностине превышает. Таблица ниже демонстрирует, что последовательность— периодическая. Последние цифры повторяются по периоду Пизано длиной. Другими словами: Например: Чтобы доказать, что последние цифры чисел Фибоначчи периодические, обратите внимание на пары остатков по модулю, следующих друг за другом чисел Фибоначчи: Каждую из колонок таблицы можно вычислить на основе предыдущей колонки как . По такой же логике колонка перед колонкой будет . Следовательно, для любой колонки в таблице выше можно однозначно определить соседей слева и справа. А значит, из любой позиции можно заполнить всю таблицу. Поскольку остатков по модулютолько, есть тольковозможных пар остатков, то есть максимумвозможных колонок. Таким образом, некоторые колонки в таблице повторяются и будут это делать до бесконечности. Докажите, что первая повторяющаяся колонка таблицы длябудет Это наводит нас на следующий простой псевдокод, который рассчитывает период Пизанодля произвольного остатка по модулю. Скопировать код1PisanoPeriod(m):2current =03next =14period =05whileTrue:6oldNext = next7next = (current + next) mod m8current = oldNext9period = period +110ifcurrent =0andnext =1:11returnperiod Объединяя изложенные идеи, получаем приемлемое по скорости работы решение. Ещё один способ вычислить— обратить внимание на то, что уравнения могут быть представлены как умножение матрицы—— и вектора: Следовательно: Поэтому— просто элемент справа вверху-й степени матрицы. Мы продемонстрируем быстрое возведение в степень с помощью целых чисел вместо матриц. Имея целое число, можно было бы примитивно вычислить, используя умножение 8 раз. Однако есть и более быстрый способ вычислить, используя умножение лишь 4 раза: В целом, при чётномвычислениепотребует выполнить умножение лишь еще один раз по сравнению с, так как. Если— нечетное, то вычислениепотребует выполнить умножение лишь ещё два раза — по сравнению с, так как. Скопировать код1FastIntegerExponentiation(x, n):2ifn =0:3return14ifn %2==0: # чётное значение5y =FastIntegerExponentiation(x, n/2)6returny * y7else: # нечётное значение8y =FastIntegerExponentiation(x, (n−1)/2)9returny * y * x Поскольку каждый рекурсивный вызовFastIntegerExponentiationприводит к двум операциям умножения целых чисел и разделяетпополам, он выполнит максимумопераций умножения. Скопировать код1FastMatrixExponentiation(D, n, m):2ifn =0:3return[[1,0], [0,1]] # единичная2×2матрица4ifn %2==0: # чётное значение5Y =FastMatrixExponentiation(D, n/2, m)6returnMultiply2x2Matrices(Y, Y, m)7else:8Y =FastMatrixExponentiation(D, (n−1)/2, m)9Y2 =Multiply2x2Matrices(Y, Y, m)10returnMultiply2x2Matrices(Y2, D, m) Скопировать код1Multiply2x2Matrices(A, B, m):2C[1][1] = (A[1][1]*B[1][1] + A[1][2]*B[2][1]) mod m3C[1][2] = (A[1][1]*B[1][2] + A[1][2]*B[2][2]) mod m4C[2][1] = (A[2][1]*B[1][1] + A[2][2]*B[2][1]) mod m5C[2][2] = (A[2][1]*B[1][2] + A[2][2]*B[2][2]) mod m6returnC Наконец, вычисление нужного значения выглядит следующим образом: Скопировать код1FibonacciModuloM(n, m):2M = [[0,1], [1,1]]3P =FastMatrixExponentiation(M, n, m)4returnP[0][1]", "useful_links": []}
{"document_title": "Задачи о числах Фибоначчи - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadachi-o-chislah-fibonachchi", "section_title": "Последняя цифра суммы чисел Фибоначчи", "text": "Формат ввода: Целое число. Формат вывода:. Ограничения:. Примеры Подсказка.Раз исчерпывающий поиск будет слишком медленным для этой задачи, попробуйте придумать формулу для. Для лучшего понимания поиграйте с маленькими значениями. Затем используйте решение для предыдущей задачи. В таблице ниже указаны первые одиннадцать чисел Фибоначчи и первые одиннадцать чисел. Похоже, что. Давайте докажем это по индукции. Это условие определённо выполняется для первого шага (), так как. Для шага с индукцией предположим, что утверждение верно для, и докажем его для: Ещё один способ прийти к формуле— сложить равенства. Так как элементы в правых частях взаимоуничтожаются, то сумма всех элементов справа —, а сумма всех элементов слева будет, Так задача сводится к тому, чтобы найти последнюю цифру в. Благодаря предыдущей задаче мы знаем, как можно быстро это сделать: исходя из того, что период Пизано по модулюравен, мы имеем", "useful_links": []}
{"document_title": "Задачи о числах Фибоначчи - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadachi-o-chislah-fibonachchi", "section_title": "Последняя цифра частичной суммы чисел Фибоначчи", "text": "Формат ввода: Целые числаи. Формат вывода:. Ограничения:. Примеры Сумма частичной суммы чисел Фибоначчи равна разнице между двумя частичными суммами: Более обобщённо, Благодаря предыдущей задаче мы знаем, как быстро вычислять префиксные, то есть первые элементы последовательности, суммы.", "useful_links": []}
{"document_title": "Задачи о числах Фибоначчи - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadachi-o-chislah-fibonachchi", "section_title": "Последняя цифра суммы квадратов чисел Фибоначчи", "text": "Формат ввода: Целое число. Формат вывода:. Ограничения:. Примеры . . Подсказка.Раз алгоритм исчерпывающего поиска будет слишком медленным для этой задачи (может доходить до), нам нужно найти простую формулу для. Рисунок выше представляет суммукак площадь прямоугольника с вертикальным реброми горизонтальным ребром. Рисунок выше подсказывает, что для каждого неотрицательного целого числа Мы докажем это по индукции. Для двух первых случаевиполучается: Для шага с индукцией предположим, что. Так, В итоге остаётся вычислить последние цифрыи.", "useful_links": []}
{"document_title": "Задачи о числах Фибоначчи - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadachi-o-chislah-fibonachchi", "section_title": "Что дальше", "text": "Теперь вы умеете вычислять числа Фибоначчи разными способами: от наивной рекурсии до оптимизированных алгоритмов с мемоизацией, итерацией и быстрым модулем. Вы познакомились с понятием периода Пизано и научились искать остатки от огромных чисел — быстро и точно. Далее — задачи на наибольший общий делитель и наименьшее общее кратное. Вы познакомитесь с алгоритмом Евклида, поймёте, почему он работает, и научитесь использовать его для ускорения решения задач с делением. А пока вы не ушли дальше — закрепите материал на практике: Отметьте, что урок прочитан, при помощи кнопки ниже. Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему. Перейдите кзадачамэтого параграфа и потренируйтесь. Перед этим — загляните в короткийгайдо том, как работает система проверки. Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте всообщество Хендбука! Там студенты помогают друг другу разобраться. Числа Фибоначчи можно вычислять по-разному — от наивной рекурсии до оптимизированных итерационных алгоритмов. Важно уметь оценивать эффективность решений: простые на вид алгоритмы могут работать слишком долго. Мемоизация и вычисление по модулю позволяют ускорить программу и избежать переполнения. Даже в знакомых задачах важно думать об ограничениях, типах данных и тестах на больших входах.", "useful_links": [{"text": "задачам", "url": "https://new.contest.yandex.ru/contest/80763"}, {"text": "гайд", "url": "https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii"}, {"text": "сообщество Хендбука", "url": "https://t.me/handbook_algorithms"}]}

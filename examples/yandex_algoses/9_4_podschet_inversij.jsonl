{"document_title": "Подсчет инверсий - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/podschet-inversij", "section_title": "Ключевые вопросы параграфа", "text": "Что такое инверсии и как их находить? Почему перебор всех пар работает медленно и как это ускорить? Как работает алгоритм подсчёта инверсий на основе сортировки слиянием?", "useful_links": []}
{"document_title": "Подсчет инверсий - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/podschet-inversij", "section_title": "Количество инверсий в последовательности", "text": "Количество инверсий в последовательности — показатель того, насколько последовательность отсортирована. Например, в неубывающей последовательности не будет инверсий, а последовательность в порядке убывания содержитинверсий (каждые два элемента образуют инверсию). Решая задачу «Количество инверсий», примитивный алгоритм просматривает все возможные пары, что требует времени выполнения. Чтобы решить эту задачу за времяс помощью алгоритма «разделяй и властвуй», мы разделяем вводный массив на две половины и делаем рекурсивный вызов обоих из них. Остаётся только вычислить количество инверсий, которые образованы двумя элементами из разных частей. Если делать это примитивным образом, то мы снова придём к времени выполнения, так как общее количество таких пар составляет. Оказывается, что если обе части уже отсортированы, количество инверсий из элементов разных половин можно вычислить за время. Это подсказывает нам, что вместо решения изначальной задачи, нам стоит решить более общую: вычислить количество инверсий в заданном массиве и в то же время отсортировать его. Измените алгоритмMergeSortдля решения этой задачи. Формат ввода: Первая строка содержит целое число, следующая — последовательность целых чисел. Формат вывода: Количество инверсий в последовательности. Ограничения:,для всех. В примере две инверсии:() и(). Совет: используйте полуоткрытые интервалы для рекурсивных реализаций Попробуем использовать самый распространённый подход к методу «разделяй и властвуй»: разделим вводную последовательность на две половины,LeftHalfиRightHalf, и выполним рекурсивный вызов для каждой. Это позволит нам вычислить все инверсии, находящиеся в одной и той же половине. Однако это не подскажет нам количество разделённых инверсий, то есть количество пар, при которыхнаходится в левой половине,находится в правой, а. Даны массиви целое число. Пустьбудет количеством элементов, которые меньше. Так как ответ на вопрос выше — это, наша задача заключается в том, чтобы быстро вычислить. Таким образом, мы приходим к следующей задаче: имея последовательность целых чисели целое число, нам нужно найти вколичество элементов, которые меньше. В случае неотсортированного массива это можно сделать за время, так как необходимо проверить каждый элемент массива. В варианте же отсортированного за время, если использовать двоичный поиск. Продемонстрируйте, как реализовать методCountSmaller(List, x)для подсчёта количества элементовсо значением меньшеза время. Так мы приходим к следующему алгоритму «разделяй и властвуй». Скопировать код1CountInversions(List):2if∣List∣ <=1:3return04inversions =05// в случае нечётной длины6// центральный элемент может быть и слева, и справа7LeftHalf = левая половина List8RightHalf = правая половина List9inversions = inversions +CountInversions(LeftHalf)10inversions = inversions +CountInversions(RightHalf)11sort(RightHalf)// необходимо для двоичного поиска12forx in LeftHalf:13inversions = inversions +CountSmaller(RightHalf,x)14returninversions Время выполнения(где— длина) удовлетворяет рекуррентному соотношению Слагаемоевключает в себя два шага: сортировкуи ответ назапросовCountSmaller. Эту рекуррентное соотношение нельзя напрямую вставить в основную теорему о рекуррентных соотношениях, так как элементне имеет формупри константе. Однако мы можем проанализировать её таким же образом: рекурсивное дерево содержитуровней, общий размер всех задач на каждом уровне равен, а общее затраченное время на каждом уровне составляет. В итоге общее время выполнения составляет. Вместо того, чтобы формально это доказывать, мы улучшим вышеприведённый алгоритм так, чтобы он затрачивал время. Можно быстро найти все разделённые инверсии, если наряду с подсчётом инверсий сортировать входную последовательность. То есть можно предположить, что алгоритмCountInversionsAndSort(List)возвращает количество инверсий ви сортирует. После двух рекурсивных вызовов обе половиныотсортированы. На данном этапе нам нужно сделать две вещи: отсортировать всю последовательностьи вычислить количество разделённых инверсий. Мы уже знаем, как достичь первой цели: этим занимается процедура. Это выглядит следующим образом.Пустьибудут первыми элементами отсортированных последовательностейи. Далее выбирается самый маленький из них и перемещается в увеличивающийся отсортированный список. Рассмотрим два случая. . В этом случаене больше каждого элемента, и поэтому не образует разделённых инверсий. . В этом случаеменьше всех элементов, и поэтому образует разделённую инверсию с каждым из них. Это приводит нас к следующему расширению методаMerge. Скопировать код1Merge(LeftHalf, RightHalf):2SortedList = empty list3inversions =04whileboth LeftHalfandRightHalf are non-empty:5l = первый элемент LeftHalf6r = первый элемент RightHalf7ifl <= r:8переместить l в SortedList9l = следующий элемент в LeftHalf10else:11переместить r в SortedList12r = следующий элемент в RightHalf13// учитываются только не перемещенные элементы14inversions = inversions + ∣LeftHalf∣15добавить все оставшиеся элементы LeftHalf и RightHalf в SortedList16returnSortedList, inversions И окончательная версия алгоритмаCountInversions. Скопировать код1CountInversions(List):2// список List будет отсортирован3if∣List∣ <=1:4return05LeftHalf = левая половина List6RightHalf = правая половина List7leftInv =CountInversions(LeftHalf)8rightInv =CountInversions(RightHalf)9List, splitInv =Merge(LeftHalf, RightHalf)10returnleftInv + rightInv + splitInv", "useful_links": []}
{"document_title": "Подсчет инверсий - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/podschet-inversij", "section_title": "Что дальше", "text": "Теперь вы умеете находить количество инверсий в массиве с помощью модифицированной сортировки. Вы увидели, как объединять рекурсивное деление с анализом данных и использовать «побочные эффекты» сортировки для аналитических целей. Далее — последняя задача главы: вы узнаете, как найти пару ближайших точек на плоскости за, используя те же идеи — сортировку, деление и точный контроль над шагами объединения. А пока вы не ушли дальше — закрепите материал на практике: Отметьте, что урок прочитан, при помощи кнопки ниже. Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему. Перейдите кзадачамэтого параграфа и потренируйтесь. Перед этим — загляните в короткийгайдо том, как работает система проверки. Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте всообщество Хендбука! Там студенты помогают друг другу разобраться. Инверсии — это пары элементов в неправильном порядке:и. Полный перебор всех пар даёт сложность, но можно улучшить до, используя сортировку слиянием. Во время слияния двух отсортированных частей можно одновременно считать количество инверсий. Такой подход позволяет комбинировать сортировку и подсчёт статистик за одно и то же время.", "useful_links": [{"text": "задачам", "url": "https://new.contest.yandex.ru/contest/80775"}, {"text": "гайд", "url": "https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii"}, {"text": "сообщество Хендбука", "url": "https://t.me/handbook_algorithms"}]}

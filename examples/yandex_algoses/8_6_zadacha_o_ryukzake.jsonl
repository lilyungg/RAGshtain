{"document_title": "Задача о рюкзаке - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-o-ryukzake", "section_title": "Ключевые вопросы параграфа", "text": "Почему жадный алгоритм не подходит для задачи о рюкзаке? Как с помощью рекурсии и мемоизации находить решение без перебора всех подмножеств? В чём разница между рекурсивной и итерационной реализациями алгоритма?", "useful_links": []}
{"document_title": "Задача о рюкзаке - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-o-ryukzake", "section_title": "Условие", "text": "Вы нашли несколько золотых слитков. Ваша цель — положить как можно больше золота в рюкзак вместимостьюфунтов. Каждый слиток существует только в одном экземпляре. При этом можно либо взять слиток целиком, либо не брать его вовсе. И хотя все слитки на рисунке выше выглядят одинаково, они обладают разным весом — он приведён ниже. Естественная жадная стратегия — взять самый тяжелый слиток, на который хватает вместимости рюкзака, и повторно проверить, а осталось ли место на ещё один слиток. При наборе слитков, приведённом выше, и рюкзаке вместимостью«жадный» алгоритм выбирает слитки весоми. Однако оптимальное решение — использовать слитки весом 4, 6 и 10! Входные данные: Первая строка ввода содержит целое число(вместимость рюкзака) и количество золотых слитков. В следующей строке приведеныцелых чисел, которые определяют вес золотых слитков. Выходные данные: Максимальный вес золотых слитков, который можно уместить в рюкзак вместимостью. Ограничения:;;. Сумма веса первого и последнего слитков равна. Вместо решения изначальной задачи проверим, можно ли выбрать поднабор слитков с общим весом, если имеемслитков весом(мы перешли на отсчёт с нуля)?", "useful_links": []}
{"document_title": "Задача о рюкзаке - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-o-ryukzake", "section_title": "Упражнение", "text": "Продемонстрируйте, как можно использовать это решение для выполнения задачи «Максимальное количество золота». Предположим, что заполнить рюкзак до конца действительно возможно: существует наборс общим весом. Включает ли он в себя последний слиток с весом? Случай 1: Если, тогда рюкзак вместимостьюможет быть заполнен первымислитками. Случай 2: Если, тогда мы можем убрать слиток с весомиз рюкзака, и вес оставшихся слитков составит. Таким образом, рюкзак с вместимостьюможно полностью заполнить первымислитками. В обоих случаях мы свели задачу к практически такой же, но с меньшим количеством слитков и меньшей вместимостью рюкзака. Так, переменнаябудет иметь значение, если существует возможность заполнить рюкзак с вместимостьюпервымислитками, и значениев остальных случаях. Анализ двух вышеприведённых случаев приводит нас к следующему рекуррентному соотношению для: Кроме того,идля любого. В целом Так как значенияварьируются между 0 и, а значения— между 0 и, мы имеемпеременных. Так какзависит от, мы обрабатываем все переменные в возрастающем порядке. В приведённом ниже псевдокоде мы используем двумерный массив pack размера, асохраняет значение. Время выполнения данного решения составляет. Скопировать код1Knapsack([w[0],…,w[n−1]],W):2pack = two-dimensional array ofsize(W+1)×(n+1)3initialize all elements of pack tofalse4pack[0][0] =true5fori from1to n:6forw from0to W:7ifw[i-1] >w:8pack[w][i] = pack[w][i−1]9else:10pack[w][i]←pack[w][i−1] OR pack[w−w[i−1]][i−1]11returnpack[W][n] В приведённой ниже двумерной таблице представлены результаты вызоваKnapsack([1,3,4], 8. F и T означают значенияfalseиtrue. Другое решение будет заключаться в анализе поднаборов всех слитков. Наша цель — найти поднабор изслитков с общим весом. Простой подход к такой задаче — просматривать все поднаборы и проверять, есть ли поднабор с весом. Так как каждый слиток можно или пропустить, или взять, каждый поднабор из трёх слитков, который мы анализируем (,,), можно представить сине-красным бинарным вектором: Теперь мы представим каждый поднабор слитков как путь, начинающийся от узласетки. Если первый бит — синий, то он соответствует синему горизонтальному сегменту сетки, связывающемус. Если первый бит — красный, то он соответствует красному сегменту сетки, связывающемус. Обработав первыебитов, мы получаем сине-красный путь отдо некого узлана сетке. Если следующий бит — синий, мы связываемс. Если следующий бит — красный, мы связываемс, как показано ниже для вектора 101: Рисунок ниже демонстрирует пути, которые соответствуют всем восьми бинарным векторам с длиной 3. Теперь мы накладываем все эти восемь путей на одну сетку: Мы классифицируем узелна сетке как истинный («true») при наличии пути откна рисунке выше. В других случаях — ложный («false»). Теперь мы можем полностью заполнить рюкзак с вместимостьюподнабором из первыхслитков, если узел— истинный («true»). Узел будет истинным в случаях, если в него проходит или синее, или красное ребро. То есть, еслиилиистинны. Это наблюдение приводит нас к предыдущему рекуррентному соотношению и к такому же решению с динамическим программированием. А вот ещё один вариант решения, который основан на мемоизации. Приведённый ниже псевдокод рекурсивно вычисляет рекуррентное соотношение из решения 1: Скопировать код1RecursiveKnapsack([w[0],…,w[n−1]],w,i):2ifi=0andw=0:3returntrue4elseifi=0andw >0:5returnfalse6elseifi >0andw_[i-1]>w:7returnRecursiveKnapsack([w[0],…,w[n−1]],w,i−1)8else:9returnRecursiveKnapsack([w[0],…,w[n−1]],w,i−1) ORRecursiveKnapsack([w[0],…,w[n−1]],w−w[i−1],i−1) ВызовRecursiveKnapsack([w_0, ..., w_{n-1}],W, n)решает задачу, но он сильно замедлен из-за необходимости перевычислять одни и те же значения снова и снова. Чтобы это продемонстрировать, рассмотрим рюкзак с вместимостьюислитков с весом,,. ВызовRecursiveKnapsack([1, 1, 1], 4, 3)создаёт рекурсивное дерево, приведённое ниже — каждый узел показывает значения. Даже в этом простом примере значениевычисляется дважды. С 20 слитками рекурсивное дерево может достичь гигантских размеров — одно и то же значение может вычисляться миллионы раз. Во избежание такого рекурсивного взрыва мы «оборачиваем» код мемоизацией с помощью ассоциативного массива, который изначально пуст. Ассоциативный массив — это абстрактный тип данных, в котором хранятся пары. Он поддерживается многими языками программирования и, как правило, реализуется как хеш-таблица или дерево поиска. К примеру, вC++иJavaассоциативный массив называется картой («map»), а вPython— словарём («dictionary»). В реализации, приведённой ниже, ассоциативный массивиспользуется для хранения логических значений для пар. Скопировать код1MemoizedKnapsack([w[0],…,w[n−1]],pack,w,i):2if(w,i) isnotin pack:3ifi=0andw=0:4pack[(w,i)] =true5elseifi=0andw >0:6pack[(w,i)] =false7elseifi >0andw_[i-1]>w:8pack[(w,i)] =MemoizedKnapsack([w[0],…,w[n−1]],pack,w,i−1)9else:10pack[(w,i)] =MemoizedKnapsack([w[0],…,w[n−1]],pack,w,i−1) ORMemoizedKnapsack([w[0],…,w[n−1]],pack,w−w[i−1],i−1)11returnpack[(w,i)] Время выполнения итогового решения составляет, так как количество рекурсивных вызовов, не являющихся уточняющими запросами в ассоциативный массив, не превышает это число. Следовательно, это такое же время выполнения, как и у соответствующего итерационного алгоритма. На практике же итерационное решение, как правило, быстрее, потому что в нём нет рекурсивных издержек и оно использует более простые структуры данных. Например, массив вместо хеш-таблицы. Тем не менее с рассматриваемой задачей ситуация иная: при некоторых наборах данных, рекурсивная версия быстрее итерационной. К примеру, если мы умножим все весовые значения на, то время выполнения итерационного алгоритма также умножится на, в то время как время выполнения рекурсивного останется таким же. В целом, если необходимо решить все возможные подзадачи, итерационный вариант обычно быстрее.", "useful_links": []}
{"document_title": "Задача о рюкзаке - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-o-ryukzake", "section_title": "Что дальше", "text": "Теперь вы умеете решать задачу о рюкзаке с помощью динамического программирования — как рекурсивно с мемоизацией, так и итерационно. Вы научились строить таблицу достижимости весов и поняли, почему простая жадность здесь не работает. Далее — задача про сувениры: вы узнаете, как свести динамическую задачу к более простой, если ограничен не вес, а количество предметов и целевая сумма. Новый подход позволит взглянуть на подмножества и веса под другим углом. А пока вы не ушли дальше — закрепите материал на практике: Отметьте, что урок прочитан, при помощи кнопки ниже. Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему. Перейдите кзадачамэтого параграфа и потренируйтесь. Перед этим — загляните в короткийгайдо том, как работает система проверки. Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте всообщество Хендбука! Там студенты помогают друг другу разобраться. Жадная стратегия не даёт оптимального решения в задаче о рюкзаке — нужно перебрать возможные комбинации. Решение строится через рекурсию с мемоизацией или итеративное заполнение таблицы достижимости. Итерационный подход обычно быстрее, но рекурсивный с мемоизацией может быть удобнее в реализации. Количество подзадач ограничено, поэтому решение работает за O(nW) — достаточно эффективно даже для больших входов.", "useful_links": [{"text": "задачам", "url": "https://new.contest.yandex.ru/contest/80780"}, {"text": "гайд", "url": "https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii"}, {"text": "сообщество Хендбука", "url": "https://t.me/handbook_algorithms"}]}

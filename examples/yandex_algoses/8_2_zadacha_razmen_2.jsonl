{"document_title": "Задача «Размен 2» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-razmen-2", "section_title": "Ключевые вопросы параграфа", "text": "Почему жадный алгоритм не справляется с задачей оптимальной сдачи? Как составить рекуррентное соотношение для минимального числа монет? В чём отличие мемоизации от табличного (bottom-up) подхода? Как реализовать решение задачи с помощью динамического программирования?", "useful_links": []}
{"document_title": "Задача «Размен 2» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-razmen-2", "section_title": "Сдача", "text": "Как нам уже известно, естественный «жадный» подход к этой задаче работает неправильно при любом наборе номиналов. Например, при номиналах,и«жадный» алгоритм разменяетцентов тремя монетами (), хотя это возможно сделать всего лишь двумя (). Ваша цель — использовать динамическое программирование для решения задачи «Сдача» с номиналами,и. Входные данные: Целое число. Выходные данные: Минимальное количество монет номиналами,,, чтобы выдать сдачу с. Ограничения:. . Для оптимального варианта сдачи снеобходимо семь монет. Рассмотрим произвольный поднабор оптимального решения — например, если сложить четыре монеты из приведённого ниже прямоугольника, то получится. Такая ситуация показывает нам важную особенность динамического программирования — решение задачи содержит решения всех её мелких подзадач. Эта особенность позволяет найти решение задачи, сначала выполняя мелкие подзадачи. Пусть— это минимальное количество монет номиналами,и, которые нужны для сдачи с, а— оптимальная сдача с. В таком случае Тогда Следовательно,. Таким образом, для решения задачи придостаточно решить её прии добавить единицу. Тем не менее мы знаем, чторавняется или, или, или. Такравно одному из следующих вариантов:,и. Так как мы ищем оптимальный способ выдать сдачу,равно минимальному из этих трёх выражений. В итоге мы получаем следующее рекуррентное соотношение: При небольших аргументах это соотношение выражает значениерекурсивным образом через собственные значения. Для такой нисходящей рекурсии нам необходимо указать базовый случай. У нас это будет:. Уравнение выше — самая важная часть алгоритма динамического программирования, так как из него легко сделать рекурсивный алгоритм. Скопировать код1Change(money):2ifmoney=0:3return04else:5result = +infinity6forc=1,3,4:7ifc <= money:8result =min(result,1+Change(money-c))9returnresult У этого алгоритма есть серьёзная проблема: он становится крайне медленным, потому что вызываетChange(money)снова и снова для одного и того же значения. Мемоизация — стандартный способ избежать этого: при вычисленииChange(money)мы можем использовать сохранение в таблице и тогда нам не придётся делать перевычисление. Скопировать код1table=associative array23Change(money):4iftable[money] isnotyet computed:5ifmoney=0:6table[money]←07else:8result = +infinity9forc=1,3,4:10ifc <= money:11result =min(result,1+Change(money-c))12table[money] = result13returntable[money] На практике такой алгоритм уже достаточно хорош, хотя у него есть проблемы с эффективностью: рекурсивные вызовы и уточняющие запросы для ассоциативного массива приводят к замедлению. Заметив, что все вычисляемые значения — это последовательные целые числа, мы можем реализовать улучшенный подход, в котором используется массив для хранения решений всех задач. Скопировать код1Change(money):2table[0..money] = [+infinity,…,+infinity]3table[0] =045form from1to money:6forc=1,3,4:7ifc <= m:8table[m] =min(table[m],1+table[m-c])9returntable[money] Время выполнения этого алгоритма составляет, так как каждая итерация внешнего циклаforпроходит за постоянное время.", "useful_links": []}
{"document_title": "Задача «Размен 2» - Основы алгоритмов", "url": "https://education.yandex.ru/handbook/algorithms/article/zadacha-razmen-2", "section_title": "Что дальше", "text": "Теперь вы умеете использовать динамическое программирование для нахождения оптимального числа монет при сдаче. Вы поняли, почему жадный подход может давать неверный результат, научились строить рекурсивные решения с мемоизацией и ускорять их с помощью таблицы. А ещё увидели, что даже простая задача может быть связана с кратчайшими путями в графах. Далее — задача на построение выражения с минимальной стоимостью вычислений. Вы научитесь определять порядок операций, который экономит ресурсы, и познакомитесь с динамическим программированием на интервалах. А пока вы не ушли дальше — закрепите материал на практике: Отметьте, что урок прочитан, при помощи кнопки ниже. Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему. Перейдите кзадачамэтого параграфа и потренируйтесь. Перед этим — загляните в короткийгайдо том, как работает система проверки. Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте всообщество Хендбука! Там студенты помогают друг другу разобраться. Жадный подход может давать неоптимальные решения в задаче размена. Динамическое программирование позволяет учитывать все варианты и выбирать наилучший. Рекурсия с мемоизацией помогает избежать повторных вычислений, но может быть медленной. Табличный (bottom-up) подход эффективнее и позволяет решать задачу за линейное время. Такие задачи часто можно представить как поиск кратчайшего пути в графе.", "useful_links": [{"text": "задачам", "url": "https://new.contest.yandex.ru/contest/80777"}, {"text": "гайд", "url": "https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii"}, {"text": "сообщество Хендбука", "url": "https://t.me/handbook_algorithms"}]}
